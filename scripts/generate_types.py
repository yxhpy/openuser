#!/usr/bin/env python3
"""
Generate TypeScript types from Pydantic schemas.

This script reads Pydantic models from src/api/schemas.py and generates
corresponding TypeScript interfaces in frontend/src/types/generated.ts
"""

import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Set
import ast


class PydanticToTypeScript:
    """Convert Pydantic models to TypeScript interfaces."""

    TYPE_MAPPING = {
        "str": "string",
        "int": "number",
        "float": "number",
        "bool": "boolean",
        "datetime": "string",  # ISO 8601 string
        "date": "string",
        "EmailStr": "string",
        "Any": "any",
        "Dict": "Record",
        "List": "Array",
    }

    def __init__(self, schema_file: Path, output_file: Path):
        self.schema_file = schema_file
        self.output_file = output_file
        self.interfaces: List[str] = []

    def parse_type(self, type_annotation: str) -> str:
        """Convert Python type annotation to TypeScript type."""
        # Handle Optional[T]
        if type_annotation.startswith("Optional["):
            inner_type = type_annotation[9:-1]
            return f"{self.parse_type(inner_type)} | null"

        # Handle List[T]
        if type_annotation.startswith("List["):
            inner_type = type_annotation[5:-1]
            return f"{self.parse_type(inner_type)}[]"

        # Handle Dict[K, V]
        if type_annotation.startswith("Dict["):
            match = re.match(r"Dict\[([^,]+),\s*(.+)\]", type_annotation)
            if match:
                key_type = self.parse_type(match.group(1))
                value_type = self.parse_type(match.group(2))
                return f"Record<{key_type}, {value_type}>"

        # Handle basic types
        return self.TYPE_MAPPING.get(type_annotation, type_annotation)

    def extract_models(self) -> List[Dict]:
        """Extract Pydantic models from schema file."""
        with open(self.schema_file, "r") as f:
            content = f.read()

        tree = ast.parse(content)
        models = []

        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                # Check if it's a Pydantic model
                for base in node.bases:
                    if isinstance(base, ast.Name) and base.id == "BaseModel":
                        model = self.parse_model(node, content)
                        if model:
                            models.append(model)
                        break

        return models

    def parse_model(self, class_node: ast.ClassDef, content: str) -> Optional[Dict]:
        """Parse a Pydantic model class."""
        model_name = class_node.name
        fields = []
        docstring = ast.get_docstring(class_node)

        for node in class_node.body:
            if isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
                field_name = node.target.id

                # Skip Config class
                if field_name == "Config":
                    continue

                # Get type annotation
                type_str = ast.unparse(node.annotation)

                # Check if field is optional (has default value)
                is_optional = node.value is not None

                # Parse the type
                ts_type = self.parse_type(type_str)

                fields.append({
                    "name": field_name,
                    "type": ts_type,
                    "optional": is_optional or "Optional" in type_str or "| None" in type_str,
                })

        return {
            "name": model_name,
            "fields": fields,
            "docstring": docstring,
        }

    def generate_interface(self, model: Dict) -> str:
        """Generate TypeScript interface from model."""
        lines = []

        # Add docstring as comment
        if model["docstring"]:
            lines.append(f"/**\n * {model['docstring']}\n */")

        # Interface declaration
        lines.append(f"export interface {model['name']} {{")

        # Fields
        for field in model["fields"]:
            optional_marker = "?" if field["optional"] else ""
            lines.append(f"  {field['name']}{optional_marker}: {field['type']};")

        lines.append("}")

        return "\n".join(lines)

    def generate(self):
        """Generate TypeScript types file."""
        print(f"Reading Pydantic schemas from {self.schema_file}...")
        models = self.extract_models()

        print(f"Found {len(models)} models")

        # Generate header
        header = """/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file is automatically generated from backend Pydantic schemas.
 * Run `python scripts/generate_types.py` to regenerate.
 *
 * Source: src/api/schemas.py
 * Generated: {timestamp}
 */

"""

        from datetime import datetime
        header = header.format(timestamp=datetime.now().isoformat())

        # Generate interfaces
        interfaces = [self.generate_interface(model) for model in models]

        # Write to file
        output_content = header + "\n\n".join(interfaces) + "\n"

        self.output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(self.output_file, "w") as f:
            f.write(output_content)

        print(f"✅ Generated TypeScript types at {self.output_file}")
        print(f"   {len(models)} interfaces created")


def main():
    # Paths
    project_root = Path(__file__).parent.parent
    schema_file = project_root / "src" / "api" / "schemas.py"
    output_file = project_root / "frontend" / "src" / "types" / "generated.ts"

    if not schema_file.exists():
        print(f"❌ Schema file not found: {schema_file}")
        sys.exit(1)

    # Generate types
    generator = PydanticToTypeScript(schema_file, output_file)
    generator.generate()


if __name__ == "__main__":
    main()
